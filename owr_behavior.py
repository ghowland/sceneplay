"""
Behavior Module


TODO(g): 
  - Make a goal for "selfdriven" or something, so the actor just goes about their own business as generated by an ever-more-complex set of possible goals, to populate the world with an autonomous agent.  Then behaviors can be going on that I dont have to think about, and they will have some sort of internal context to drive them.  Perhaps joining up various actors into interacting with each other, and also having themes for locations, where it could be "happy" or "distrustful" or something, and then all the self-driven actors are behaving according to each other (not a driven character, who must not be interfered with because that would change the actual given instructions for the play)

"""

import math
from random import randint

import owr_base


# Cache all the actor state (positions, etc)
ACTOR_CACHE = {}


#TODO(g): These are just for "person" handler, not cameras or other kinds of handlers...
# Known goal keys
#TODO(g): "loop" (or reset?) will flip the goals to their original state, so that the list
#   of goals repeats again
GOAL_KEYS = ['random', 'follow', 'fight', 'go', 'jump', 'get', 'throw at', 'throw', 
             'enter', 'exit', 'bounce', 'pummel', 'victim', 'loop', 'look', 'look at', 
             'pick up']
GOAL_KEYS.sort()

# Goal Keys which require selection from the Viewport to set their values
VIEWPORT_SELECT_GOAL_KEYS = ['go', 'jump', 'pos', 'enter', 'exit']

# Goal Keys which require selection from a ButtonMap of Actor names
ACTOR_SELECT_GOAL_KEYS = ['fight', 'throw at', 'look at', 'pummel', 'pick up']

# Default goal keys and their values for a given GOAL_KEY
GOAL_DEFAULTS = {
  'jump': {
    'height':45, 
  },
  'bounce': {
    'height':10, 
    'count':None,
  },
}

# These default goal_keys are added to every goal, because they apply to all goals
GLOBAL_ALWAYS_DEFAULTS = {
  'duration':None,    # Always unspecified duration, unless specified
  'say':None,         # Any action can have a Say specified to get dialogue while performing it
  #'say offset':None,  # Offset to start saying things ---  NO!  Use Speech Timeline
}

# Goal Keys which require a slider to change their values
#NOTE(g): dict, keys on goal_key, value is tuple (min, max), if None is specified that value is unlimited
SLIDER_SELECT_GOAL_KEYS = {
  'height':(None, None), 
  'duration':(0, None),
}


def ClearCache():
  global ACTOR_CACHE
  ACTOR_CACHE = {}


def CameraHandler(game, data, current_time, actor_name, actor, state, interval, recursion_depth=0):
  """Update the Behavior for a 'person' actor"""
  actor_state = dict(actor)
  actor_state['action'] = 'camera'

  return actor_state


def PersonHandler(game, data, current_time, actor_name, actor, state, interval, recursion_depth=0):
  """Update the Behavior for a 'person' actor"""
  if recursion_depth > 1:
    raise Exception('PersonHandler should never recurse more than once.  Thats all it takes to re-do something that just changed modes.')

  global ACTOR_CACHE
  # State to return
  actor_state = {}

  # Copy the data
  actor_state['data'] = actor['data']
  #actor_state['offset'] = actor['offset']

  # Variables
  random_range_x = [0, 500]
  random_range_y = [375, 500]


  # Default action is to stand
  actor_state['action'] = 'stand'

  # Animation counter is modulused by frames if it animates straight through
  actor_state['animation_counter'] = 0

  # Position
  #TODO(g): This isnt good enough.  Where do I get this?
  actor_state['pos'] = state['pos']

  # If they are in a non-goal Mode, handle that
  if state['mode'] != None:
    # If the actor is stunned
    if state['mode'] == 'stunned':
      print '%s: stunned: %s' % (actor_name, state['animation_playing_time'])
      stun_duration = 1.5

      if state['animation_playing_time'] == None:
        state['animation_playing_time'] = 0

        # Set to increment the stun counter
        if 'stun_count' not in state:
          state['stun_count'] = 0
        else:
          state['stun_count'] += 1

          # Reset stun counter, so we alternate
          if state['stun_count'] >= 3:
            state['stun_count'] = 0

      else:
        state['animation_playing_time'] += interval

      if state['stun_count'] < 2:
        actor_state['action'] = 'hit_forward_hard'
      else:
        actor_state['action'] = 'knocked_out'

      # If we're done being stunned, clear ourself and run this Person Handler again
      if state['animation_playing_time'] >= stun_duration:
        SetActorStateMode(state, None)
        PersonHandler(game, data, current_time, actor_name, actor, state, interval, recursion_depth=recursion_depth+1)

    # Handle unknown state mode (code error)
    else:
      raise Exception('Unknown Behavior state mode: %s: %s' % (actor_name, state['mode']))


  # If there are no goals or we have completed them all, then return as-is, totally default
  if not actor['goal'] or state['goal_number'] >= len(actor['goal']):
    print 'All goals completed: %s' % actor_name
    return actor_state

  # Use this goal, as default
  goal = actor['goal'][state['goal_number']]


  # Dont process any normal behaviors if the is a State Mode (processed above)
  if state['mode'] != None:
    pass

  # Else, go somewhere
  elif goal.get('go', False):
    state['target_pos'] = owr_base.Position(goal['go'][0], goal['go'][1])

    # If we're not yet close enough, walk
    close_enough_to_target = 10.0
    if state['pos'].GetDistance(state['target_pos']) > close_enough_to_target:
      # Process this Action
      ProcessAction(game, current_time, 'walk', interval, actor_name, state, actor_state, state['target_pos'])
    else:
      IncrementActorGoalNumber(game, current_time, state)
      PersonHandler(game, data, current_time, actor_name, actor, state, interval, recursion_depth=recursion_depth+1)

  # Else, jump somewhere
  elif goal.get('jump', False):
    state['target_pos'] = owr_base.Position(goal['jump'][0], goal['jump'][1])

    # Process this Action
    #TODO(g): Put goal in normal data args, not optional
    completed = ProcessAction(game, current_time, 'jump', interval, actor_name, state, actor_state, state['target_pos'], goal=goal)
    if completed:
      IncrementActorGoalNumber(game, current_time, state)
      PersonHandler(game, data, current_time, actor_name, actor, state, interval, recursion_depth=recursion_depth+1)

  # Else, Handle random movement
  elif goal.get('random', False):
    # If we dont already have a target to walk towards, make one randomly
    if not state.get('target_pos', None):
      (tx, ty) = (randint(random_range_x[0], random_range_x[1]), randint(random_range_y[0], random_range_y[1]))
      state['target_pos'] = owr_base.Position(tx, ty)

    # Process this Action
    ProcessAction(game, current_time, 'walk', interval, actor_name, state, actor_state, state['target_pos'])

    # If we're close enough, clear this target
    close_enough_to_target = 10.0
    if state['pos'].GetDistance(state['target_pos']) < close_enough_to_target:
      state['target_pos'] = None

  # Else, if this is Follow movement
  elif goal.get('follow', False):
    # Only follow if we have them cached, by name
    if goal['follow'] in ACTOR_CACHE:
      target = ACTOR_CACHE[goal['follow']]

      # Process this Action
      ProcessAction(game, current_time, 'walk', interval, actor_name, state, actor_state, target['pos'], speed_modifier=0.4)


  # Else, if this is Fight goal
  elif goal.get('fight', False):
    # Only fight if we have them cached, by name
    if goal['fight'] in ACTOR_CACHE:
      target = ACTOR_CACHE[goal['fight']]

      # If we're close enough, clear this target
      close_enough_to_target = 60.0
      if state['pos'].GetDistance(target['pos']) < close_enough_to_target:
        state['target_pos'] = None

        # Punch opponent
        if target['mode'] != 'stunned':
          ProcessAction(game, current_time, 'punch', interval, actor_name, state, actor_state, target)

        # Else, stand and wait (for now...)
        else:
          actor_state['action'] = 'stand'


      # Else, close distance to opponent
      else:
        #TODO(g): Test for jump requirement

        # Process this Action
        ProcessAction(game, current_time, 'walk', interval, actor_name, state, actor_state, target['pos'])



  # Set the position based on the updated saved state
  actor_state['pos'] = state['pos'].Duplicate()


  return actor_state



def ProcessAction(game, current_time, action, interval, actor_name, state, actor_state, target, speed_modifier=1.0, goal=None):
  """Allow duplicate Behavior goal paths to reach the same action
  
  TODO(g): Put goal in normal data args, not optional
  """

  # Assume this isnt completed.  This function doesnt always know if its completed or not
  completed = False

  actor_state['action'] = action

  # Walk (towards a target)
  if action == 'walk':
    distance_covered = 100 * interval
    animate_increment_distance = 25 # Walk

    # Move towards our target, slower
    state['pos'].MoveTowardPos(target, distance_covered * speed_modifier)
    actor_state['animation_counter'] = int(state['pos'].traveled) / int(animate_increment_distance)

  # Jump (to position)
  elif action == 'jump':
    #TODO(g):HARDCODED: Jumps always last 3 seconds
    jump_time = 3.0
    land_time = state['goal_start'] + jump_time
    if current_time > land_time:
      completed = True
    else:
      distance_covered = 100 * interval
      animate_increment_distance = 25 # Walk

      # Move towards our target, slower
      state['pos'].MoveTowardPos(target, distance_covered * speed_modifier)

      # duration = current_time - state['goal_start']
      # duration_ratio = duration / float(jump_time)
      # sin_wave = math.sin(duration_ratio * math.pi)

      # print ' Jump Duration: %s   Ratio: %s  Sin: %s  Game: %s  Start: %s' % (duration, duration_ratio, sin_wave, game.time_elapsed, state['goal_start'])

      ## Add height change to Actor
      #state['pos'].height += goal['height'] * sin_wave

      # If we havent touched the Inertia yet
      if state['pos'].inertia.IsReset():
        state['pos'].inertia.ApplyForce(0, 0, goal['height'])
      else:
        state['pos'].inertia.ApplyForce(0, 0, interval * -100.0)

      state['pos'].inertia.UpdatePosition(state['pos'])

      # Dont go below the ground
      #TODO(g): This needs to become general purpose world phsics, not this silliness
      if state['pos'].height < 0.0:
        state['pos'].inertia.Reset()
        state['pos'].height = 0

        # We have completed this Jump
        completed = True


      actor_state['animation_counter'] = int(state['pos'].traveled) / int(animate_increment_distance)

  # Punch a target actor
  elif action == 'punch':
    # Seconds of duration
    punch_duration = 0.3

    if state['animation_playing_time'] == None:
      state['animation_playing_time'] = 0
    else:
      state['animation_playing_time'] += interval

    # If we are done punching this time, go back to standing
    #TODO(g): Any overrides for this, in general?  Running?  ('running punch')
    if state['animation_playing_time'] >= punch_duration:
      actor_state['action'] = 'stand'

      # Clear the animation playing time, were done
      #TODO(g): Wrap this in helped function?  Might be a good idea.  Think on it...
      state['animation_playing_time'] = None

      # The target has been punched, switch them to stunned mode
      print 'Target stunned'
      SetActorStateMode(target, 'stunned')

      # We have indeed fought the target
      IncrementActorGoalNumber(game, current_time, state)

    # Else, the punch is still going on
    else:
      #TODO: Get these from our animation database, they are important
      PUNCH_FRAME_COUNT = 3

      # Move towards our target, slower
      actor_state['animation_counter'] = int(PUNCH_FRAME_COUNT * state['animation_playing_time'] / float(punch_duration))

  # Completed isnt always set, because we dont always know, sometimes it happens in the calling function
  return completed


def IncrementActorGoalNumber(game, current_time, state):
  """Increments the actor goal number, sets the actor goal start time."""
  state['goal_number'] += 1
  state['goal_start'] = current_time
  print ' - Incrementing Actor Goal Number -'


def SetActorStateMode(state, mode, reset=False):
  """Set an Actor's cached mode, so we can behave differently than directed.

  Doesnt change goal_number.
  """
  print 'SetActorStateMode: %s' % mode

  if mode != state['mode'] or reset:
    state['animation_playing_time'] = None

  state['mode'] = mode
  


def GetActorCacheState(game, current_time, actor_name, actor):
  global ACTOR_CACHE

  # If state is missing, create it.  We will store data we update each frame there
  if actor_name not in ACTOR_CACHE:
    state = {'mode':None, 'animation_playing_time':None, 'goal_number':0, 'goal_start': current_time}
    state['pos'] = owr_base.Position(actor['pos'][0], actor['pos'][1])
    print 'Creating Actor Cache: %s' % actor_name
    ACTOR_CACHE[actor_name] = state
  else:
    state = ACTOR_CACHE[actor_name]

  return state


def Update(game, data, current_time, actor_name, actor, interval):
  """Update the Behavior for actors"""
  state = GetActorCacheState(game, current_time, actor_name, actor)

  # Ensure at least an empty dict exists for the goal (no goal)
  if 'goal' not in actor:
    actor['goal'] = []

  # Get the Handler for this actor
  handler = actor.get('handler', None)

  if handler == 'person':
    updated_actor = PersonHandler(game, data, current_time, actor_name, actor, state, interval)
  elif handler == 'camera':
    updated_actor =  CameraHandler(game, data, current_time, actor_name, actor, state, interval)
  else:
    print actor
    raise Exception('Unknown Behavior Handler: %s: %s' % (actor_name, handler))

  # Save this current frame's state in a new dict
  #NOTE(g): Any deep values will be lost (Pos, lists, dicts, etc) as later versions
  #   will overwrite them.  I dont need that data at this point, so this is a
  #   known tradeoff.  Right now Im looking for goal_number, which is an int.
  updated_actor['__state__'] = dict(state)
  #print 'Updated Actor: %s' % updated_actor

  return updated_actor


